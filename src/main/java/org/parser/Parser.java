package org.parser;

import org.lexer.*;
import org.nodes.*;

/**
 * Parser class to mount the AST tree.
 */
public class Parser {
    // Lexer to tokenize the input string
    Lexer lexer;

    // Pointer for the AST tree
    RegexNode head;

    // Error generated during the parser
    ErrorType error;

    /**
     * The start symbol of the grammar, represents the top-level structure of the
     * language.
     *
     * <expression> ::= <union> | <basic-expression>
     * 
     * @return new node if the parser was successful, or null otherwise.
     */
    RegexNode expression() {
        return basicExp();
    }

    /**
     * Non-terminal symbol of the grammar, represents the basic operators that
     * we can found in the grammar.
     *
     * <basic-expression> ::= <star> | <elementary-expression>
     * 
     * @return new RegexNode() if the parser was successful, or null otherwise.
     */
    RegexNode basicExp() {
        RegexNode elem = elementaryExp();
        if (lexer.peek() == Token.STAR) {
            return star(elem);
        }

        return elem;
    }

    /**
     * Non-terminal symbol of the grammar, represents the star operation that
     * we can found in the grammar.
     *
     * <star> ::= <elementary-expression> "*"
     * 
     * @return new RegexNode() if the parser was successful, or null otherwise.
     */
    RegexNode star(RegexNode node) {
        lexer.consume();
        return new StarNode(null, node);
    }

    /**
     * Non-terminal symbol of the grammar, represents more operators of the grammar,
     * and some other terminal symbols.
     *
     * <elementary-expression> ::= <group> | <char>
     * 
     * @return new RegexNode() if the parser was successful, or null otherwise.
     */
    RegexNode elementaryExp() {
        if (lexer.peek() == Token.PARENTHESE_OPEN) {
            return group();
        }

        return charExp();
    }

    /**
     * Non-terminal symbol of the grammar, represents the star operation of the
     * grammar.
     *
     * <group> ::= "(" <expression> ")"
     * 
     * @return new RegexNode() if the parser was successful, or null otherwise.
     */
    RegexNode group() {
        lexer.consume();

        GroupNode groupNode = new GroupNode(null, null);
        RegexNode aux = groupNode;

        while (lexer.peek() != Token.PARENTHESE_CLOSE) {
            if (aux == groupNode) {
                aux.setRight(expression());
                aux = aux.getRight();
            } else {
                aux.setLeft(expression());
                aux = aux.getLeft();
            }
        }

        lexer.consume();
        return groupNode;
    }

    /**
     * Terminal symbol of the grammar, represents a character or a
     * meta-character.
     *
     * <char> ::= any-non-metachar | '\' metachar
     * 
     * @return new node if the parser was successful, or null otherwise.
     */
    RegexNode charExp() {
        lexer.consume();
        CharNode node = new CharNode(null, null, lexer.getConsumedSymbol());
        return node;
    }

    /**
     * Contructor of the parser.
     *
     * @param input Regular expression to be parsed. This should not be null.
     */
    public Parser(String input) {
        this.lexer = new Lexer(input);
        this.error = ErrorType.SUCCESSFUL;
    }

    /**
     * Sets a new regular expression to be parsed.
     *
     * @param input Regular expression to be parsed. This should not be null.
     */
    public void setInput(String input) {
        lexer.setInput(input);
        head = null;
    }

    /**
     * Parses the regular expression currently saved.
     *
     * @return 0 if the the expression could be parsed, and a negative number
     *         otherwise.
     */
    public int parse() {
        head = expression();

        RegexNode aux = head;
        while (lexer.peek() != Token.EOF) {
            aux.setLeft(expression());
            aux = aux.getLeft();
        }

        if (head.getLeft() == null) {
            return error.getValue();
        }

        return 0;
    }

    /**
     * Getter for the AST generated by the parser
     *
     * @return the head pointer of the AST.
     */
    public RegexNode getAST() {
        return head;
    }
}
